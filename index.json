[{"content":"Grayscaling an image can be broken down into two components: the Chroma (Color) and the Luma (Brightness). if we desaturate an image completely (remove color), what is left is the Grayscaled version of that image. some people might refer to grayscale as \u0026ldquo;black and white\u0026rdquo;, however that\u0026rsquo;s not a technically accurate term for that. black and white would mean that all the pixels of the image is either black or white, the image would be made of only 2 colors (Binary Image). a grayscale image on the other hand could be made of 50 shades of gray (usually much more).\nHow It Works? to grayscale the screen our fragment shader runs for every pixel and replace the color with a shade of gray that represents the brightness of that pixel.\nThe Recipe add a new ColorRect and make it Fullscreen and add a new ShaderMaterial to it and create a new shader for it(See How).\na new shader looks like this:\nshader_type canvas_item; void fragment() { // Place fragment code here. } step 1: get the pixel color our grayscale shader needs to read the screen, we do that like so:\nshader_type canvas_item; uniform sampler2D SCREEN_TEXTURE : hint_screen_texture, filter_linear_mipmap; void fragment() { vec4 pixelColor = texture(SCREEN_TEXTURE, SCREEN_UV); } we add a uniform calledSCREEN_TEXTURE(you can call it anything you like).\nThe uniform declaration forSCREEN_TEXTUREincludes two hints:hint_screen_textureandfilter_linear_mipmap. hint_screen_texturetells Godot that this uniform should be automatically set to the screen texture, andfilter_linear_mipmapspecifies that the texture should be filtered using linear interpolation and mipmapping. These hints help ensure that the screen texture is sampled correctly and efficiently in the shader.\nwe then sample theSCREEN_TEXTUREinto a variable calledpixelColorusing thetexture()function.\nthepixelColorvariable now holds the color of the current pixel, we\u0026rsquo;ll use it to calculate the brightness.\nstep 2: calculate the pixel brightness there are two methods for calculating the pixel brightness:\naveraging the RGB channels dotting the RGB with the \u0026ldquo;Luma Coefficients\u0026rdquo; method 1 a pixel is made of a Red, Green and Blue channel and if all of them are equal then it\u0026rsquo;s not either Red, Green or Blue; it\u0026rsquo;s Grayscaled!\nthis method simply averages the red, green, and blue values of the pixel color to calculate the brightness of the pixel which will then be set to the RGB channels of the same pixel. This is a simpler and more straightforward method.\nfloat pixelBrightness = (pixelColor.r + pixelColor.g + pixelColor.b) / 3.0; method 2 this method uses the Dot Product of the pixel color (in RGB format) and a vector of weights (0.299, 0.587, 0.114) known as the \u0026lsquo;Luma Coefficients\u0026rsquo; to calculate the brightness. This method is based on the fact that the human eye is more sensitive to green light than to red or blue, so the weights are chosen to reflect this sensitivity. we can store the luma coefficients in a constant declared above our fragment function.\nconst vec3 LUMA_COEFFICIENTS = vec3(0.299, 0.587, 0.114); and then use it to calculate the pixel\u0026rsquo;s luma.\nfloat pixelBrightness = dot(pixelColor.rgb, LUMA_COEFFICIENTS); Photometry is the science of measuring light in terms of its perceived brightness to the human eye. The human eye is most sensetive to green light, followed by red light, and least sensetive to blue light.\nif we average the RGB to calculate the pixel brightness, a completely blue pixelvec3(0.0, 0.0, 1.0)and a completely green pixelvec3(0.0, 1.0, 0.0)would both become(0.333, 0.333, 0.333)and they would look exactly the same, and therefore it would not be an accurate representation of how the human eye perceives brightness.\nThe luma coefficients work because they take into account the way the human eye perceives brightness. grayscaled with luma coefficients\ngrayscaled by averaging RGB\nleft: averaging RGB right:luma coefficients\npay attention to the light bulbs!\nstep 3: grayscale the pixel we compose a vector4 that haspixelBrightnessfor the RGB and1.0for the Alpha (full opacity).\nvec4 grayscale = vec4(vec3(pixelBrightness), 1.0); there\u0026rsquo;s quite a bit of flexibility in terms of syntax when it comes to composing vectors. if we pass only one scalar (numerical quantity) to the vector\u0026rsquo;s constructor, it will construct a vector that has the same scalar for all of the components(xyz\u0026hellip;), this is known as a uniform vector (DO NOT confuse with theuniformkeyword; they\u0026rsquo;re totally not the same thing!).vec3(pixelBrightness)would produce the same vector asvec3(pixelBrightness, pixelBrightness, pixelBrightness).\nyou can compose a vector by passing any combonation of vectors and scalars, for examplevec4(vec3(pixelBrightness), 1.0) and vec4(pixelBrightness, pixelBrightness, pixelBrightness, 1.0) would produce the same vector as well.\nnext we need to output this grayscaled pixel:\nCOLOR = grayscale; there\u0026rsquo;s a built-in variable in Godot shaders calledCOLORwhich is the currect pixel\u0026rsquo;s color.\nin some shading programs we might have to return the color but in Godot the fragment shader is avoidfunction.\nhere\u0026rsquo;s the final shader:\nshader_type canvas_item; uniform sampler2D SCREEN_TEXTURE : hint_screen_texture, filter_linear_mipmap; uniform vec4 tint : source_color = vec4(0); const vec3 LUMA_COEFFICIENTS = vec3(0.299, 0.587, 0.114); void fragment() { vec4 pixelColor = texture(SCREEN_TEXTURE, SCREEN_UV); float pixelBrightness = dot(pixelColor.rgb, LUMA_COEFFICIENTS); vec4 grayscale = vec4(vec3(pixelBrightness), 1.0); COLOR = grayscale; } ","permalink":"https://mohammad9760.github.io/PostProcessing_Cookbook/posts/grayscaling/","summary":"Grayscaling an image can be broken down into two components: the Chroma (Color) and the Luma (Brightness). if we desaturate an image completely (remove color), what is left is the Grayscaled version of that image. some people might refer to grayscale as \u0026ldquo;black and white\u0026rdquo;, however that\u0026rsquo;s not a technically accurate term for that. black and white would mean that all the pixels of the image is either black or white, the image would be made of only 2 colors (Binary Image).","title":""}]